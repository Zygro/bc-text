\chapter{Dokumentácia servera}
\label{kap:doc}

\lstdefinelanguage{Python}{
  keywords={self,while,if,len,filter,id,all,for,else,in,not},
  keywordstyle=\color{deepblue}\bfseries,
  ndkeywords={def,return},
  ndkeywordstyle=\color{purple}\bfseries,
  stringstyle=\color{deepgreen}\ttfamily,
  morestring=[b]",
  morestring=[b]',
}
\lstset{
  language = Python,
  frame=single,
  otherkeywords={},             % Add keywords here
  keywordstyle=\color{deepblue},
  basicstyle=\small\ttfamily,
  numberstyle=\small,
  emph={MyClass,__init__},          % Custom highlighting
  emphstyle=\color{deepred},    % Custom highlighting style
  frame=tb,                         % Any extra options here
  showstringspaces=false,            %
  numbersep=9pt,
  tabsize=2,
  backgroundcolor=\color{lightgray},
  numbers=left,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
}


V tejto kapitole sa pozrieme na prvú pracovnú implementáciu servera. Oboznámime sa
s modelmi, pohľadmi a niektorými funkciami, ich možnosťami a použitím.
\section{Modely}
\label{modely}
Django servery sledujú návrhový vzor Model-View-Controller (MVC)\cite{Django}. V prípade Django servrov, model je tabuľka
databázy a view je spôsob zobrazenia (napríklad vo forme HTML stránky). Pre pochopenie
funkcionality je dôležité vedieť, aké modely a pohľady používame a ako medzi sebou interagujú.
\newline
Tu sa oboznámime s dôležitými modelmi, teda tabuľkami databázy.
Pri každom modeli spomenieme jeho názov v implementácii a slovenský ekvivalent tohto názvu.

(Každý model obsahuje aj pole id, čo je jedinečné identifikačné číslo automaticky generované
Django frameworkom)
\subsection{Lesson - úloha}
\label{doc:lesson}
Ako prvý si predstavíme asi najdôležitejší model servera, ktorý obsahuje zadanie a
testovacie dáta úlohy.

Úlohy majú tieto polia:
\begin{itemize}
\itemsep0em
\item \textbf{name}: meno úlohy ktoré sa zobrazuje používateľovi.
\item \textbf{problem}: znenie úlohy.
\item \textbf{pub\_date}: dátum publikácie úlohy.
\item \textbf{number}: úroveň úlohy, používateľ musí mať vyriešené všetky povinné úlohy s
  na nižších úrovniach aby mal k tejto úlohe prístup.
\item \textbf{optional}: voliteľnosť úlohy. Povinné aj voliteľné úlohy sa odomykajú rovnako, voliteľné
   ale neodomykajú neskoršie úlohy.
\item \textbf{inputs}: vstupy na ktorých prebieha testovanie úlohy.
\item \textbf{correct\_solution}: správne riešenie, oproti ktorému sa budú testovať používateľské
   riešenia.
\end{itemize}

Pridávanie a upravovanie úloh je jednoduché - stačí v administrátorskom prostredí vyplniť polia
a uložiť. Na každej úrovni ale musí byť práve jedna povinná úloha, preto po upravení
alebo pridaní novej povinnej úlohy sa poradie upraví tak, aby pridaná alebo zmenená úloha mala
po uložení číslo, ktoré jej administrátor zadal. Viac si o spôsobe zarovnania úloh povieme v časti
\ref{implementacia:posuvanie}

Na úlohy máme tri rôzne pohľady (views): Jeden ktorý vráti všetky úrovne, voliteľnosti a názvy úloh ku ktorým má
používateľ prístup, druhý meno, znenie a úroveň s voliteľnosťou jednej úlohy a tretí
iba vstupy alebo skript na stiahnutie (ak používame testovač \ref{testovac1} alebo \ref{testovac2})

\subsection{User - používateľ}
Model s osobnými údajmi používateľa.

Polia:
\begin{itemize}
\item \textbf{username}: prezývka používateľa, nutná na registráciu a prihlásenie, jedinečná
\item \textbf{email}: emailová adresa používateľa, tiež nutná a jedinečná
\item \textbf{password}: heslo používateľa, ukladané pomocou hash funkcie poskytovanej
                        REST frameworkom
\item \textbf{first\_name}: prvé meno používateľa, nepovinné
\item \textbf{last\_name}: priezvisko používateľa, taktiež nepovinné
\end{itemize}

Pri vytvorení nového používateľa sa automaticky vytvorí jeho \textbf{UserStat} (\ref{modelUserStat})
\newline
Tu takisto môžem spomenúť model \textbf{Token}, ktorý má polia \textbf{user} a \textbf{key}.
\textbf{Token} je používaný pri autorizácii (\ref{authorization}). Je generovaný
pri každom prihlásení a zmazaný pri každom odhlásení.
\newpage
\subsection{Submit - riešenie}
Riešenie, ktoré používateľ pošle na server na otestovanie.

Polia:
\begin{itemize}
\item \textbf{user}: používateľ ktorý riešenie poslal
\item \textbf{lesson}: úloha ktorú používateľ rieši týmto riešením
\item \textbf{submittedFile}: súbor s riešením, ktoré bude odovzdané testovaču
\item \textbf{result}: výsledok - reťazec znakov obsahujúci výpis z testovača
\end{itemize}

Hneď ako server dostane nové riešenie, spustí testovač (\ref{impl:testovac}) a jeho odpoveď uloží v poli
\textbf{result}. Ak nie je správne, riešenie iba uložíme a ďalej s ním nič nerobíme.
Ak testovač ale vyhodnotí riešenie ako správne (testovač vráti \lstinline[language=Python]{"OK"}), pred jeho uložením zvýši používateľovu
úroveň o 1 (ak je úloha povinná) a označí úlohu ako vyriešenú v modeli \textbf{UserLessonWrapper} (\ref{modelWrapper}).

\subsection{Comment - komentár}
Komentár od používateľa na úlohu.
Polia:
\begin{itemize}
\item \textbf{user}: používateľ ktorý vytvoril komentár
\item \textbf{lesson}: úloha ku ktorej bol komentár pridaný
\item \textbf{text}: text komentára
\item \textbf{date}: čas vytvorenia komentára, potrebný na zoraďovanie pri zobrazení
\end{itemize}

Zatiaľ sú všetky komentáre prístupné všetkým používateľom (ak majú prístup k ich úlohe).

\subsection{Hint - rada}
Rada k úlohe, pre prípad že ju používateľ nevie riešiť.

Polia:
\begin{itemize}
\item \textbf{lesson}: úloha ku ktorej je táto rada
\item \textbf{number}: poradové číslo rady
\item \textbf{text}: text rady
\end{itemize}

Používateľovi sa pri zobrazení úlohy ukazuje iba toľko rád, o koľko si požiadal. Táto
informácia sa ukladá v modeli \textbf{UserLessonWrapper} (\ref{modelWrapper}).
Používateľ môže kedykoľvek požiadať o ďalšiu radu. Kým existuje nepoužitá rada, zväčšíme
číslo použitých rád v \textbf{UserLessonWrapper}-i a odpovieme novým, o jednu položku dlhším zoznamom rád.

\subsection{Rating - hodnotenie}
Používateľovo hodnotenie úlohy v kategóriach zložitosti a zábavnosti.

Polia:
\begin{itemize}
\item \textbf{user}: používateľ, ktorý zaslal toto hodnotenie
\item \textbf{lesson}: úloha, ktorú hodnotil
\item \textbf{fun}: hodnotenie zaujímavosti
\item \textbf{difficulty}: hodnotenie zložitosti
\end{itemize}

Keďže každý používateľ môže ohodnotiť každú úlohu iba raz,
pre každú dvojicu \textbf{úloha-používateľ} môže existovať najviac jedno hodnotenie.

Kým používateľ nevyriešil úlohu, používateľské prostredie mu nezobrazí formulár na hodnotenie.
Týmto sa snažíme o to aby nemal spôsob, ako poslať hodnotenie úlohy ktorú nevyriešil.
Napriek tomu, zavedieme opatrenie proti
možnosti manuálne poslať požiadavku a tým obísť podmienku správneho vyriešenia úlohy:
pred uložením hodnotenia na servri znova overíme, či používateľ úlohu správne vyriešil.
Ak a mu to ešte nepodarilo, odpoveď na poslanie hodnotenia bude chyba 401-UNAUTHORIZED.

Ak sa používateľovi ale podarilo úlohu predtým
vyriešiť, vytvoríme nové alebo upravíme existujúce hodnotenie a obnovíme model \textbf{LessonStat} (\ref{modelLessonStat}),
aby mal aktuálne dáta.
\subsection{LessonStat - štatistika úlohy}
\label{modelLessonStat}
Model, ktorý zbiera štatistické dáta o úlohe, ktoré budú neskôr spracované a ukázané administrátorovi.
K tomuto modelu má prístup iba administrátor.

Polia:
\begin{itemize}
\item \textbf{lesson}: úloha ku ktorej štatistika patrí
\item \textbf{avg\_fun}: priemerné hodnotenie zaujímavosti
\item \textbf{avg\_diff}: priemerné hodnotenie zložitosti
\item \textbf{good\_solutions}: počet používateľov ktorí úlohu správne vyriešili
  (nie počet správnych riešení, pretože účelom tohto poľa je pomôcť zistiť koľko riešení
  používatelia skúšajú pred správnym vyriešením)
\item \textbf{bad\_solutions}: počet zlých riešení úlohy pred správnym vyriešením úlohy
\end{itemize}

\subsection{UserStat - štatistika používateľa}
\label{modelUserStat}
V momentálnej implementácii zbierame iba jeden údaj pre používateľov, ktorý ale používame
na zisťovanie, ktoré úlohy používateľovi sprístupniť. Narozdiel od modelu \textbf{LessonStat} (\ref{modelLessonStat}),
táto štatistika je prístupná používateľovi, pretože ide o jeho výsledky.

Tento model bude vo finálnom produkte obsahovať napríklad aj skóre používateľa, ktoré
bude podľa priania používateľa zverejnené v rebríčku (\ref{score})

Polia:
\begin{itemize}
\item \textbf{user}: používateľ
\item \textbf{progress}: úroveň používateľa - počet správne vyriešených povinných úloh
\end{itemize}

\subsection{UserLessonWrapper - obal používateľ-úloha}
\label{modelWrapper}
Model na určovanie postupu používateľa jednou úlohou. Používa sa iba na vnútorné
overovanie prístupu používateľa k niektorým modelom. Tento model je unikátny pre každú
dvojicu používateľ-úloha

Polia:
\begin{itemize}
\item \textbf{user}: používateľ
\item \textbf{lesson}: úroveň používateľa - počet správne vyriešených povinných úloh
\item \textbf{hints\_used}: počet použitých rád k úlohe
\item \textbf{completed}: či používateľ správne vyriešil úlohu
\end{itemize}

Tento model sprístupníme administrátorovi na upravovanie, pretože chceme mať možnosť
opravovať nepredvídané chyby (napríklad ak používateľ pošle správne riešenie ale
úloha sa mu neoznačí za vyriešenú).

\protect\section{Pomocné funkcie}
Teraz si popíšeme implementáciu automatického testovača a zarovnávania pridaných úloh, pretože obe sú dôležité
funkcie, ktoré by sme mali ovládať.
\subsection{Testovač}
\label{impl:testovac}
Testovač je v prvej pracovnej verzii implementovaný podľa najjednoduchšieho prístupu \ref{testovac1}.

Uvedieme si popis kódu testovača a potom aj samotný kód.

Najprv overíme, či riešenie je .zip súbor. Ak nie, hneď vypíšeme hlášku \newline\lstinline[language=Python]{"Not a .zip file"}.
Potom otvoríme používateľove a správne riešenie úlohy v knižnici zipfile.
Ďalej overíme, či počet súborov je rovnaký. Ak nie, vypíšeme chybovú hlášku \newline\lstinline[language=Python]{"Wrong file structure"}.

Potom pre všetky súbory zo správneho riešenia skúsime nájsť súbor s rovnakým menom
v používateľovom riešení. Ak ho nenájdeme, tiež vypíšeme chybu \newline\lstinline[language=Python]{"Wrong file structure"}.
Ak ho nájdeme, ale obsah súboru sa líši v
používateľovom a správnom riešení, vyhodnotíme riešenie za nesprávne (hláška \lstinline[language=Python]{"Wrong answer"}).

Ak všetky súbory z používateľovho riešenia prejdú týmito testami, vieme povedať,
že všetky súbory sa zhodovali s tými v správnom riešení a teda riešenie je správne.
V tom prípade testovač vráti \lstinline[language=Python]{"OK"}.
\begin{lstlisting}[title = testovač]
def compare_files(correctFile, submitFile):
  if (not zipfile.is_zipfile(submitFile)):
      return "Not a .zip file"
  correct = zipfile.ZipFile(correctFile)
  submit = zipfile.ZipFile(submitFile)
  if len(correct.namelist()) != len(submit.namelist()):
      return "Wrong file structure"
  for name in correct.namelist():
      if name not in submit.namelist():
          return "Wrong file structure"
      if submit.read(name) != correct.read(name):
          return "Wrong answer"
  return "OK"
\end{lstlisting}

Nevýhodou je, že používateľove súbory musia mať rovnaké meno ako tie v správnom riešení,
preto je na autorovi úlohy aby v zadaní popísal správny formát riešenia.

My odporúčame ako konvenciu používanie vstupných súborov s príponou .in a výstupov
s rovnakým menom, ale príponou .out (napríklad vstupný súbor 01.a.in a korešpondujúci výstupný súbor 01.a.out)

\subsection{Posúvanie úloh}
\label{implementacia:posuvanie}
Je na administrátorovom uvážení, ktorá úloha sa bude nachádzať v ktorej úrovni.
Preto môže úlohy nie len pridávať, ale aj posúvať. V každej úrovni ale musí
byť práve jedna povinná úloha. Preto na pridanie novej alebo zmenu úrovne existujúcej
povinnej úlohy by administrátor musel posúvať ostatné existujúce úlohy,
čo môže byť časovo náročné a môžu vzniknúť chyby. Preto tento proces automatizujeme,
aby sme administrátorovi uľahčili prácu.

Funkciu automatického zarovnávania
spojíme s modelom \textbf{Lesson} pomocou signálu \lstinline[language=Python]{post_save}.
Tento signál nám zaručí, že pri uložení úlohy sa zavolá zarovnávacia funkcia.

Algoritmus zarovnávania sleduje tieto kroky:
\begin{itemize}
\item Všetky povinné úlohy posunieme tak, aby neboli žiadne medzery v poradí.
\item všetky povinné úlohy čo majú úroveň väčšiu alebo rovnú úrovni upravovanej/pridanej
 úlohy posunieme o jednu úroveň vyššie (upravovaná/pridaná úloha nie je posunutá).
\item všetky úlohy znovu posunieme tak, aby sme vyplnili medzery (pretože predošlý krok mohol
    vytvoriť nové medzery ak presúvame existujúcu úlohu na vyššiu úroveň)
\item nakoniec pridáme ukladanú úlohu a zarovnáme ju tiež, nakoľko administrátor mohol urobiť chybu a pridať úlohu
    s číslom väčším ako počet povinných úloh a teda by bola nedosiahnuteľná.
\end{itemize}

Vypĺňanie medzier sa uskutočňuje pomocou \lstinline[language=Python]{while} cyklu,
v ktorom dekrementujeme úroveň zarovnávanej úlohy, až kým nenarazíme na prvú povinnú úlohu ktorá má
úroveň o 1 menšiu ako práve zarovnávaná úloha. Vtedy cyklus skončíme a môžme si byť istí,
že v každej úrovni menšej alebo rovnej úrovni zarovnávanej úlohy je práve jedna povinná úloha.

Na ukladanie zmien používame metódu \lstinline[language=Python]{Lesson.update()} miesto
\lstinline[language=Python]{Lesson.save()}. \lstinline[language=Python]{Lesson.save()} totiž zavolá
\lstinline[language=Python]{post_save} signál, ktorý by spustil proces zarovnávania, ktorý by tiež
spustil ďalší proces zarovnávania a funkcia by nikdy neskončila.

Ako nové číslo úlohy v metóde \lstinline[language=Python]{Lesson.update()} používame pri posúvaní úloh hore výraz F,
konkrétne \lstinline[language=Python]{F('number')}. Tento výraz F nám dovoľuje získať hodnotu
poľa práve obnovovaného objektu bez toho, aby sme mu priradili premennú čím skracujeme
a sprehľadňujeme kód. V ostatných prípadoch výraz F nie je potrebný, pretože už máme
obnovovanú úlohu označenú premennou l alebo instance.
\newpage
\begin{lstlisting}[language=Python, title = Posúvanie úloh]
def PushOtherLessons (sender, instance, *args, **kwargs):
  rank = instance.number
  non_optionals = [x for x in Lesson.objects.all().order_by('number')if not(x.optional) and x.id!=instance.id]
  #fill the gaps
  print(non_optionals)
  for l in non_optionals:
    while len(Lesson.objects.filter(number = (l.number-1), optional = False))==0 and l.number>1:
      Lesson.objects.filter(id=l.id).update(number = l.number-1)
      l.number -= 1
      print(l)
  #push later lessons one level up
  if not(instance.optional):
    if len(Lesson.objects.filter(number=rank))>0:
      Lesson.objects.filter(number__gte = rank, optional=False).exclude(id=instance.id).update(number = F('number')+1)
  non_optionals = [x for x in Lesson.objects.all().order_by('number') if not(x.optional) and x.id!=instance.id]
  #fill the gaps again
  for l in non_optionals:
    while len(Lesson.objects.filter(number = (l.number-1), optional = False))==0 and l.number>1:
      Lesson.objects.filter(id=l.id).update(number = l.number-1)
      l.number -= 1
  #adjust saved lesson
  if (not instance.optional):
    while len(Lesson.objects.filter(number = (instance.number-1)))==0 and instance.number>1:
      Lesson.objects.filter(id=instance.id).update(number = instance.number-1)
      instance.number -= 1
post_save.connect(PushOtherLessons, sender=Lesson)
\end{lstlisting}

\chapter{Dokumentácia servra}
\label{kap:doc}

\lstdefinelanguage{Python}{
  keywords={self,while,if,len,filter,id,all,for,else,in,not},
  keywordstyle=\color{deepblue}\bfseries,
  ndkeywords={def,return},
  ndkeywordstyle=\color{purple}\bfseries,
  stringstyle=\color{deepgreen}\ttfamily,
  morestring=[b]",
  morestring=[b]',
}
\lstset{
  language = Python,
  frame=single,
  otherkeywords={},             % Add keywords here
  keywordstyle=\color{deepblue},
  basicstyle=\small\ttfamily,
  numberstyle=\small,
  emph={MyClass,__init__},          % Custom highlighting
  emphstyle=\color{deepred},    % Custom highlighting style
  frame=tb,                         % Any extra options here
  showstringspaces=false,            %
  numbersep=9pt,
  tabsize=2,
  backgroundcolor=\color{lightgray},
  numbers=left,
  breaklines=true,
  postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
}


V tejto kapitole sa pozrieme na prvú pracovnú implementáciu návrhu servra. Oboznámime sa
s modelmi, pohľadmi a niektorými funkciami, ich možnosťami a použitím.
\section{Modely}
\label{modely}
Django servery sledujú návrhový vzor Model-View-Controller (MVC), kde model je tabuľka
databázy a view je spôsob zobrazenia (napríklad vo forme HTML stránky). Pre pochopenie
funkcionality je dôležité vedieť aké modely a pohľady používame a ako medzi sebou interagujú,
preto sa s nimi oboznámime.

Tu sa oboznámime s dôležitými modelmi, teda tabuľkami databázy.
Pri každom modeli spomenieme jeho názov v implementácii a slovenský ekvivalent tohto názvu.

(Každý model obsahuje aj pole id, čo je jedinečné identifikačné číslo automaticky generované
Django frameworkom)
\subsection{Lesson - úloha}
\label{doc:lesson}
Úlohy majú tieto polia:
\begin{itemize}
\itemsep0em
\item \textbf{name}: meno úlohy ktoré sa zobrazuje používateľovi.
\item \textbf{problem}: znenie úlohy.
\item \textbf{pub\_date}: dátum publikácie úlohy.
\item \textbf{number}: úroveň úlohy, používateľ musí mať vyriešené všetky povinné úlohy s
  na nižších úrovniach aby mal k tejto úlohe prístup.
\item \textbf{optional}: voliteľnosť úlohy. Povinné aj voliteľné úlohy sa odomykajú rovnako, voliteľné
   ale neodomykajú neskoršie úlohy.
\item \textbf{inputs}: vstupy na ktorých prebieha testovanie úlohy.
\item \textbf{correct\_solution}: správne riešenie, oproti ktorému sa budú testovať používateľské
   riešenia.
\end{itemize}

Pridávanie úloh je jednoduché - stačí vyplniť polia v administrátorskom prostredí
a uložiť. Na každej úrovni ale musí byť práve jedna povinná úloha, preto po upravení
alebo pridaní novej povinnej úlohy sa poradie upraví tak, aby pridaná alebo zmenená úloha mala
po uložení číslo, aké jej administrátor zadal. Viac si o spôsobe zarovnania úloh povieme v časti
\ref{implementacia:posuvanie}

Na úlohy máme tri rôzne pohľady (views): Jeden ktorý vráti všetky úrovne, voliteľnosti a názvy úloh ku ktorým má
používateľ prístup, druhý meno, znenie a úroveň s voliteľnosťou jednej úlohy a tretí
iba vstupy alebo skript na stiahnutie (ak používame testovač \ref{testovac1} alebo \ref{testovac2})

\subsection{User - používateľ}
Model s osobnými údajmi používateľa

Polia:
\begin{itemize}
\item \textbf{username}: prezývka používateľa, nutná na registráciu a prihlásenie, jedinečná
\item \textbf{email}: emailová adresa používateľa, tiež nutná a jedinečná
\item \textbf{password}: heslo používateľa, ukladané pomocou hash funkcie poskytovanej
                        REST frameworkom
\item \textbf{first\_name}: prvé meno používateľa, nepovinné
\item \textbf{last\_name}: priezvisko používateľa, taktiež nepovinné
\end{itemize}

Pri vytvorení nového používateľa sa automaticky vytvorí jeho \textbf{UserStat} (\ref{modelUserStat})
\newline
Tu takisto môžem spomenúť model \textbf{Token}, ktorý má polia \textbf{user} a \textbf{key}.
\textbf{Token} je používaný pri autorizácii (\ref{authorization}) a je vygenerovaný
pri každom prihlásení a zmazaný pri odhlásení.
\newpage
\subsection{Submit - riešenie}
Riešenie ktoré používateľ pošle na server na otestovanie.

Polia:
\begin{itemize}
\item \textbf{user}: používateľ ktorý riešenie poslal
\item \textbf{lesson}: úloha ktorú používateľ rieši týmto riešením
\item \textbf{submittedFile}: súbor s riešením, ktoré bude odovzdané testovaču
\item \textbf{result}: výsledok - reťazec znakov obsahujúci výpis z testovača
\end{itemize}

Hneď ako server dostane nové riešenie, spustí testovač a jeho odpoveď uloží v poli
\textbf{result}. Ak nie je správne, riešenie uložíme a ďalej s ním nič nerobíme.
Ak testovač ale vyhodnotí riešenie ako správne (výpis \lstinline[language=Python]{"OK"}), pred jeho uložením zvýši používateľovu
úroveň o 1 (ak je úloha povinná) a označí úlohu ako vyriešenú v modeli \textbf{UserLessonWrapper} (\ref{modelWrapper}).

\subsection{Comment - komentár}
Komentár od používateľa na úlohu.
Polia:
\begin{itemize}
\item \textbf{user}: používateľ ktorý vytvoril komentár
\item \textbf{lesson}: úloha ku ktorej bol komentár pridaný
\item \textbf{text}: text komentára
\item \textbf{date}: čas vytvorenia komentára, potrebný na zoraďovanie pri zobrazení
\end{itemize}

Pri komentároch sa bude zobrazovať aj úroveň autora a to, či úlohu vyriešil.
Zatiaľ sú všetky komentáre prístupné všetkým používateľom (ak majú prístup k ich úlohe)


\subsection{Hint - rada}
Rada k úlohe, pre prípad že ju používateľ nevie riešiť.

Polia:
\begin{itemize}
\item \textbf{lesson}: úloha ku ktorej je táto rada
\item \textbf{number}: poradové číslo rady
\item \textbf{text}: text rady
\end{itemize}

Používateľovi sa pri zobrazení úlohy ukazujú iba toľko rád koľko si požiadal. Táto
informácia sa ukladá v modeli \textbf{UserLessonWrapper} (\ref{modelWrapper}).
Používateľ môže požiadať o ďalšiu radu a kým existuje nepoužitá rada, zväčšíme
číslo použitých rád v \textbf{UserLessonWrapper}-i a odpovieme novým, o jednu randu dlhším zoznamom rád.

\subsection{Rating - hodnotenie}
Hodnotenie úlohy v kategóriach zložitosti a zábavnosti.

Polia:
\begin{itemize}
\item \textbf{user}: používateľ ktorý zaslal toto hodnotenie
\item \textbf{lesson}: úloha ktorú hodnotil
\item \textbf{fun}: hodnotenie zaujímavosti
\item \textbf{difficulty}: hodnotenie zložitosti
\end{itemize}

Pre každú dvojicu \textbf{úloha-používateľ} môže existovať iba jedno hodnotenie,
čo znamená že každý používateľ môže ohodnotiť každú úlohu iba raz.

Kým používateľ nevyriešil úlohu, prehliadač mu nezobrazí formulár na hodnotenie,
preto by nemal mať spôsob ako poslať hodnotenie úlohy ktorú nevyriešil.
Napriek tomu, zavedieme opatrenie proti
možnosti manuálne poslať požiadavku a tým obísť podmienku správneho vyriešenia úlohy:
pred uložením hodnotenia overíme aj na servri či používateľ úlohu správne vyriešil.
Ak a mu to ešte nepodarilo, ako odpoveď na poslanie hodnotenia dostane chybu UNAUTHORIZED.

 Ak sa mu ale podarilo úlohu predtým
vyriešiť, vytvoríme nové alebo upravíme existujúce hodnotenie a obnovíme model \textbf{LessonStat} (\ref{modelLessonStat})
aby mal aktuálne dáta.
\subsection{LessonStat - štatistika úlohy}
\label{modelLessonStat}
Model ktorý zbiera štatistické dáta o úlohe, ktoré budú neskôr spracované a ukázané administrátorovi.
K tomuto modelu má prístup iba administrátor.

Polia:
\begin{itemize}
\item \textbf{lesson}: úloha ku ktorej štatistika patrí
\item \textbf{avg\_fun}: priemerné hodnotenie zaujímavosti
\item \textbf{avg\_diff}: priemerné hodnotenie zložitosti
\item \textbf{good\_solutions}: počet používateľov ktorí úlohu správne vyriešili
  (nie počet správnych riešení, pretože účelom tohto poľa je pomôcť zistiť koľko riešení
  používatelia skúšajú pred správnym vyriešením)
\item \textbf{bad\_solutions}: počet zlých riešení úlohy pred správnym vyriešením úlohy
\end{itemize}

\subsection{UserStat - štatistika používateľa}
\label{modelUserStat}
V momentálnej implementácii zbierame iba jeden údaj pre používateľov, ktorý ale používame
na zisťovanie, ktoré úlohy používateľovi sprístupniť. Narozdiel od modelu \textbf{LessonStat} (\ref{modelLessonStat}),
táto štatistika je prístupná používateľovi, pretože ide o jeho výsledky.

Tento model bude vo finálnej obsahovať napríklad aj skóre používateľa, ktoré
bude podľa priania používateľa zverejnené v rebríčku (\ref{score})

Polia:
\begin{itemize}
\item \textbf{user}: používateľ
\item \textbf{progress}: úroveň používateľa - počet správne vyriešených povinných úloh
\end{itemize}

\subsection{UserLessonWrapper - obal používateľ-úloha}
\label{modelWrapper}
Model na určovanie postupu používateľa jednou úlohou. Používa sa iba na vnútorné
overovanie prístupu používateľa k niektorým modelom. Tento model je unikátny pre každú
dvojicu používateľ-úloha

Polia:
\begin{itemize}
\item \textbf{user}: používateľ
\item \textbf{lesson}: úroveň používateľa - počet správne vyriešených povinných úloh
\item \textbf{hints\_used}: počet použitých rád k úlohe
\item \textbf{completed}: či používateľ správne vyriešil úlohu
\end{itemize}

Tento model sprístupníme administrátorovi na upravovanie, pretože chceme mať možnosť
opravovať nepredvídané chyby (napríklad ak používateľ pošle správne riešenie ale
úloha sa mu neoznačí za vyriešenú).

\protect\section{Pomocné funkcie}
Teraz si popíšeme implementáciu automatického testovača a zarovnávania pridaných úloh, pretože obe sú dôležité
funkcie, ktoré by sme mali ovládať.
\subsection{Testovač}
Testovač je v prvej pracovnej verzii implementovaný podľa najjednoduchšieho prístupu \ref{testovac1}

Uvedieme si popis kódu testovača a potom si ho aj uvedieme.

Tento testovač otvorí používateľove a správne riešenie úlohy ako .zip súbor.
Najprv overí, či počet súborov je rovnaký. Ak nie, vypíše chybovú hlášku.

Potom pre všetky súbory zo správneho riešenia skúsi nájsť súbor s rovnakým menom
v používateľovom riešení. Ak ho nenájde, vypíše chybu. Ak ho nájde, ale obsah súboru sa líši v
používateľovom a správnom riešení, vyhodnotí riešenie za nesprávne.

Ak všetky súbory z používateľovho riešenia prejdú týmito testami, vieme povedať,
že všetky súbory sa zhodovali s tými v správnom riešení a teda riešenie je správne.

\begin{lstlisting}[title = testovač]
  def compare_files(correctFile, submitFile):
      correct = zipfile.ZipFile(correctFile)
      submit = zipfile.ZipFile(submitFile)
      if len(correct.namelist()) != len(submit.namelist()):
          return "Wrong file structure"
      for name in correct.namelist():
          if name not in submit.namelist():
              return "Wrong file structure"
          if submit.read(name) != correct.read(name):
              return "Wrong answer"
      return "OK"
\end{lstlisting}

Nevýhodou je, že používateľove súbory musia mať rovnaké meno ako tie v správnom riešení,
preto je na autorovi úlohy aby v zadaní popísal správny formát riešenia.

My odporúčame ako konvenciu používanie vstupných súborov s príponou .in a výstupov
s rovnakým menom, ale príponou .out (napríklad vstupný súbor 01.a.in a výstupný 01.a.out)

\subsection{Posúvanie úloh}
\label{implementacia:posuvanie}
Každá úroveň úloh musí mať presne jednu povinnú úlohu. Keďže chceme, aby administrátor
nemusel úlohy posúvať sám pred pridaním novej alebo pred presunutím existujúcej na inú úroveň,
tento proces zarovnávania si automatizujeme.

Prejdeme tieto kroky:
\begin{itemize}
\item Všetky povinné úlohy posunieme tak, aby neboli žiadne medzery v poradí.
\item všetky povinné úlohy čo majú úroveň väčšiu alebo rovnú úrovni upravovanej/pridanej
 úlohy posununieme o jednu úroveň vyššie (upravovaná/pridaná úloha nie je posunutá).
\item všetky úlohy znovu posununieme tak, aby sme vyplnili medzery (pretože predošlý krok mohol
    vytvoriť nové medzery ak presúvame existujúcu úlohu na vyššiu úroveň)
\item nakoniec pridáme ukladanú úlohu a zarovnáme ju tiež, nakoľko administrátor mohol urobiť chybu a pridať úlohu
    s číslom väčším ako počet povinných úloh a teda by bola nedosiahnuteľná.
\end{itemize}

\begin{lstlisting}[language=Python, title = Posúvanie úloh]
def PushOtherLessons (sender, instance, *args, **kwargs):
  if not(instance.optional):
    rank = instance.number
    non_optionals = [x for x in Lesson.objects.all().order_by('number')
      if not(x.optional) and x.id!=instance.id]
    #fill the gaps
    for l in non_optionals:
      while len(Lesson.objects.filter(number = (l.number-1)))==0 and l.number>1:
        Lesson.objects.filter(id=l.id).update(number = l.number-1)
        l.number -= 1
        print(l)
    #push later lessons one level up
    if len(Lesson.objects.filter(number=rank))>0:
      Lesson.objects.filter(number__gte = rank, optional=False).exclude(id=instance.id).update(number = F('number')+1)
    non_optionals = [x for x in Lesson.objects.all().order_by('number') if not(x.optional) and x.id!=instance.id]
    #fill the gaps again
    for l in non_optionals:
      while len(Lesson.objects.filter(number = (l.number-1)))==0 and l.number>1:
        Lesson.objects.filter(id=l.id).update(number = l.number-1)
        l.number -= 1
    #adjust saved lesson
    while len(Lesson.objects.filter(number = (instance.number-1)))==0 and instance.number>1:
      Lesson.objects.filter(id=instance.id).update(number = instance.number-1)
      instance.number -= 1
post_save.connect(PushOtherLessons, sender=Lesson)
\end{lstlisting}

Vypĺňanie medzier sa uskutočňuje pomocou \lstinline[language=Python]{while} cyklu,
v ktorom dekrementujeme úroveň zarovnávanej úlohy, až kým nenarazíme na prvú povinnú úlohu ktorá má
úroveň o 1 menšiu ako práve zarovnávaná úloha. Vtedy cyklus skončíme a môžme si byť istí,
že po túto úlohu žiadne medzery neexistujú.

Na ukladanie zmien používame metódu \lstinline[language=Python]{Lesson.update()} miesto
\lstinline[language=Python]{Lesson.save()} pretože \lstinline[language=Python]{Lesson.save()} zavolá
\lstinline[language=Python]{post_save} signál, ktorý by spustil proces zarovnávania, ktorý by tiež
spustil ďalší proces zarovnávania a funkcia by nikdy neskončila.

Ako nové číslo úlohy v metóde \lstinline[language=Python]{Lesson.update()} používame pri posúvaní úloh hore výraz F,
konkrétne \lstinline[language=Python]{F('number')}. Tento výraz F nám dovoľuje získať hodnotu
poľa práve obnovovaného objektu bez toho, aby sme mu priradili premennú čím skracujeme
a sprehľadňujeme kód. V ostatných prípadoch výraz F nie je potrebný, pretože už máme
obnovovanú úlohu označenú premennou l alebo instance.

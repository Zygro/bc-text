\chapter{Dokumentácia používateľského prostredia}
\lstdefinelanguage{JavaScript}{
  keywords={typeof, new, true, false, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break},
  keywordstyle=\color{blue}\bfseries,
  ndkeywords={class, export, boolean, throw, implements, import, this},
  ndkeywordstyle=\color{purple}\bfseries,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{//},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgray}\ttfamily,
  stringstyle=\color{deepgreen}\ttfamily,
  morestring=[b]',
  morestring=[b]"
}
\lstset{
   language=JavaScript,
   backgroundcolor=\color{lightgray},
   extendedchars=true,
   basicstyle=\small\ttfamily,
   showstringspaces=false,
   showspaces=false,
   numbers=left,
   numberstyle=\footnotesize,
   numbersep=9pt,
   tabsize=2,
   breaklines=true,
   postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}},
   showtabs=false,
   captionpos=b
}

\label{kap:frontImpl}
V tejto kapitole si priblížime implementáciu prednej časti portálu, s ktorou
budú používatelia interagovať. Povieme si komunikácii so serverom ale aj o
implementácii vizualizácie rekurzívnych výpočtov.
\section{Stránky a ich adresy}
V prvej pracovnej verzii sú implementované tieto stránky (uvedené s URL adresami)
\begin{itemize}
  \item registrácia - \textit{/user/register/}
  \item prihlasovanie - \textit{/user/login/}
  \item zoznam úloh - \textit{/lessons/}
  \item detail úlohy - \textit{/lesson/id/} (id je unikátne identifikačné číslo úlohy)
  \item vizualizácia - \textit{/visualisation/}
  \item administrátorské prostredie - \textit{/admin/}
\end{itemize}

Administrátorské prostredie je predvolené prostredie Django frameworku bez modifikácií.
Toto prostredie poskytuje všetky požadované možnosti (prezeranie, pridávanie, úprava
a mazanie objektov) vo veľmi prehľadnej a jednoduchej forme.
\subsection{Komunikácia so serverom}
Na komunikáciu so serverom používame hlavne knižnicu jQuery, konkrétne asynchronickú metódu AJAX, kvôli jej jednoduchému
používaniu a podpore pridania autorizačnej hlavičky. Autorizačná hlavička
je údaj v hlavičke HTTP požiadavky ktorý určuje totožnosť používateľa, v našom prípade napríklad
\lstinline[language=Javascript]|{'Authorization': 'Token a5b498587e33d1f44a97c2328618dd15373b0705'}|.

Tento token dostaneme ako odpoveď na prihlasovaciu požiadavku a uložíme si ho
v lokálnej pamäti prehliadača pomocou zavolania
\lstinline[language=Javascript]|localStorage|, konkrétne takto:\newline
\lstinline[language=Javascript]|localStorage.setItem('token', response['token'])|.
Potom token môžme kedykoľvek získať pomocou zavolania metódy
\lstinline[language=Javascript]|getItem()|.
Väčšina požiadaviek ktoré posielame na server sú si veľmi podobné, preto uvedieme
iba jednu typickú požiadavku:

\begin{lstlisting}[ language = Javascript, title = Požiadavka na získanie rád k úlohe]
$.ajax({
  url: "../../api/hints/"+id,
  type: "GET",
  headers: {'Authorization':'Token '+localStorage.getItem('token')},
  success: function(data) {
    hintTarget = document.getElementById("hints")
    var hintArray = []
    for (var i = 0; i < data.length; i++) {
      hintTarget.innerHTML += "<li>"+data[i].text+"</li>"
    }
  },
  error: function(data) {
    if (data.status==401) {
      window.location.replace("../../user/login/")
    }
  }
});
\end{lstlisting}

Tento a viacero iných podobných, požiadavok posielame vždy pri načítaní stránky
prehliadačom, aby sme získali dáta ktoré chceme zobraziť.

Teraz si vysvetlíme niektoré časti tohto kódu:\newline
V druhom riadku používame premennú id, ktorá označuje unikátne identifikačné číslo
úlohy. Toto číslo získame z URL zobrazenej stránky ako prvú vec pri načítaní.

Vo štvrtom riadku pridávame autorizačnú hlavičku, podľa spôsobu, aký sme popísali vyššie.

Pod kľúčom \lstinline[language=Javascript]|success| deklarujeme správanie pri úspešnom získaní odpovede
od servra, v tomto prípade zobrazujeme získané rady v zozname.

Pod kľúčom \lstinline[language=Javascript]|fail| deklarujeme správanie sa pri chybe. Zatiaľ jediná
chyba, na ktorú reagujeme je 401-UNAUTHORIZED. Tú dostaneme, ak posielame
správu s nesprávnym alebo úplne chýbajúcim tokenom. V tom prípade používateľa presmerujeme
na prihlasovaciu stránku. Toto správanie je použité v každej požiadavke, ktorá
vyžaduje autentifikáciu.

Odosielanie na server je o trochu iné, pretože používa metódu POST a musíme pridať
aj posielané dáta. To najčastejšie robíme pomocou pridania \newline
\lstinline[language=Javascript]{data : $("#form_id").serialize()}, čo nám dáta
získa priamo z hodnôt vo formulári.

jQuery má ale obmedzenie, že kvôli bezpečnosti nedokáže zapisovať do súborov na disku.
To znamená, že sťahovanie súborov je náročné na implementáciu. Preto na sťahovanie
vstupných súborov (pre implementáciu jednoduchého testovača \ref{testovac1}) používame
formulár, ktorý pošle GET požiadavku na požadovanú adresu. Tento formulár ale nemôže mať
hlavičku s tokenom, preto sťahovanie vstupov nebude autentifikovať používateľa.

To síce znamená, že používateľ môže mať prístup aj k vstupom úloh, ktoré si ešte neodomkol.
Tento problém nepovažujeme za závažný, pretože bez zadania úlohy je malá šanca že používateľ
túto úlohu vyrieši. Ďalej, vo finálnom produkte testovač nebude vyžadovať sťahovanie
dát, čím bude tento problém úplne odstránený.

Rovnako, jQuery má ťažkosti s posielaním súborov bez použitia ďalších pluginov.
Preto na posielanie riešení používame formát XMLHttpRequest, ktorý
funguje podobne ako AJAX, preto si ho ďalej približovať nebudeme.

\section{Vizualizácia}
Vizualizácia rekurzívnych výpočtov (ďalej len vizualizácia) má za úlohu z používateľovej
funkcie vytvoriť strom jej výpočtu a ten prehľadne vykresliť. Naša implementácia
najskôr vygeneruje celý strom a až potom ho používateľovi zobrazí.

Štýl vizualizácie a niektoré časti implementácie sú inšpirované projektom
VisuAlgo. Tento projekt tiež obsahuje vizualizáciu rekurzívnych výpočtov \cite{visualgo},
ale zobrazovanie memoizačných výpočtov v tomto projekte je pre naše účely nepostačujúce.

Na vyhodnotenie funkcie používame Javascript a na vykresľovanie používame HTML5 objekt canvas.
Vďaka tomu všetok kód vizualizácie je v HTML dokumente, čo znamená že vizualizácia nijak nekomunikuje so serverom.

Popis implementácie vizualizácie si rozdelíme na štyri časti. Najskôr si spomenieme
formát a obmedzenia zadávateľných funkcií. Ako druhé si opíšeme kroky
pred generovaním stromu, potom generovanie vrcholov stromu a nakoniec vykresľovanie.

\subsection{Formát}
Vizualizácia akceptuje iba funkcie písané v jazyku Javascript. Kvôli jednoduchšej implementácii
sa vyhodnocovaná funkcia vždy volá \lstinline[language=Javascript]{f}. Používateľov
vstup budeme načítavať z dvoch textových vstupov: v jednom napíše názvy parametrov
a ich počiatočné hodnoty a v druhom samotné telo funkcie.
\subsection{Príprava}
Po stlačení tlačidla Evaluate si uložíme kód do textovej premennej. Parametre si uložím
ako reťazec v ktorom sú jednotlivé parametre oddeľované čiarkami a argumenty si
uložím do jednorozmerného poľa. Potom pomocou Javascriptovej funkcie \lstinline[language=Javascript]{eval}
si vstupný kód a parametre prevediem na funkciu ktorú si uložím pod menom \lstinline[language=Javascript]{originalFunction}.

Pokračujem tým, že si ako \lstinline[language=Javascript]{f} uložím modifikovanú zapisovaciu funkciu
ktorú si predstavíme v ďalšej sekcii. Tento krok je veľmi dôležitý, pretože odteraz, vždy keď zavoláme funkciu
f v používateľovom kóde, v skutočnosti nespustíme funkciu ktorú zadal, ale jej modifikovanú,
zapisovaciu verziu. Máme jednu zapisovaciu funkciu pre obyčajný rekurzívny výpočet
a druhú pre memoizačný.

Ako posledný krok prípravy túto modifikovanú funkciu spustím
na parametroch ktoré používateľ zadal.

\subsection{Tvorba stromu výpočtu}
Vrcholy stromu si ukladáme do poľa a získavame ich iba pomocou indexovania tohto
poľa, aby sme zaručili že každý vrchol máme uložený v pamäti iba v jednej kópii.

Počas výpočtu si vrcholy vkladáme do zásobníka, aby sme vedeli určiť, ktorý vrchol
je rodičom ktorého. O detailoch ukladania a vyberania si povieme neskôr.

Pri memoizácii si pamätáme ešte aj prvé výskyty argumentov, čiže zoznam vrcholov
v ktorých ukladáme do pamäte nový údaj. Tento zoznam potrebujeme, aby sme vedeli
ukázať, kedy sme vypočítali hodnotu v pamäti.

Pre každý vrchol stromu výpočtu si pamätáme nasledovné údaje:

\begin{itemize}
  \item poradie v zozname vrcholov
  \item poradie rodiča v zozname vrcholov
  \item pole argumentov
  \item návratovú hodnotu
  \item či sme získali hodnotu vrchola z pamäti (iba pri memoizácii)
  \item zoznam detí (tiež ich poradí v zozname)
  \item hĺbku v strome - používané na zistenie y-ovej súradnice
  \item počet listov, ktoré sú potomkom tohto vrchola (1 ak tento vrchol je list) - používané na zistenie
    x-ovej súradnice
  \item súradnice stredu pri vykresľovaní
  \item či ukazujeme výsledok (potrebu tohto údaja si vysvetlíme v časti Vykresľovanie)
\end{itemize}

Ako prvé si v modifikovanej funkcii určíme poradie vrchola a jeho otca. Číslo
je veľkosť zoznamu vrcholov a rodič je vrchol na konci zásobníka. Zároveň pridáme
nový vrchol do zoznamu rodičovich detí. Hĺbkou vrchola je dĺžka zásobníka.
Vrchol pridáme do zoznamu všetkých vrcholov.

Ak máme zapnutú memoizáciu, na tomto mieste overíme, či nemáme pre argumenty nového
vrchola v pamäti už vypočítanú hodnotu. Ak áno, označíme vrchol ako získaný z pamäte, priradíme mu
návratovú hodnotu a vrátime ju. Ak nemáme hodnotu v pamäti, pokračujeme ďalej ako
bez memoizácie.

Teraz overíme, či vrcholov nie je viac ako 1000. Ak áno, výpočet zastavíme
a používateľovi ukážeme chybovú hlášku. Týmto zabránime nekonečnému volaniu a príliš
veľkým a pamäťovo náročným simuláciám.
\newline
\newline
Aby sme zistili návratovú hodnotu, pridáme vrchol do zásobníka a ako
hodnotu priradíme návratovú hodnotu z originálnej funkcie na rovnakých argumentoch.

Originálna funkcia pri výpočte
buď hodnotu vráti hneď, alebo ďalej volá funkciu f. f ale je naša zapisovacia
funkcia. Preto originálna funkcia pri svojom výpočte zavolá zapisovaciu funkciu
miesto volania samej seba (s rovnakými argumentami, ako by volala samú seba).
Naša zapisovacia funkcia pre všetky argumenty vráti tú istú hodnotu ako pôvodná funkcia.
To znamená, že výpočet originálnej a zapisovacej funkcie sa vetví rovnako.
Preto všetky volania pôvodnej funkcie budú zapísané našou zapisovacou funkciou ako
vrcholy stromu.

V prípade memoizácie uložíme dvojicu argumenty-výsledok do
pamäte a pridáme tento vrchol do zoznamu prvých výskytov argumentov.

Nakoniec ako počet listov pod terajším vrcholom uložíme sumu počtov listov pod deťmi,
odstránime terajší vrchol zo zásobníka a vrátime hodnotu.

\subsection{Vykresľovanie}
V tejto časti si najskôr opíšeme vykresľovanie rekurzie bez memoizácie. Potom
si spomenieme zmeny v implementácii pre výpočet s
memoizáciou.

V každom kroku buď odhalíme nový vrchol, alebo návratovú hodnotu jedného
z už vykreslených vrcholov. Návratovú hodnotu vykreslíme zároveň s vrcholom iba pri listoch.

Všetky ostatné vrcholy najprv vykresľujeme bez návratovej hodnoty. Tú odhalíme, iba keď
je odhalená návratová hodnota všetkých jeho detí. Tento prístup simuluje výpočet v ktorom
poznáme návratovú hodnotu až vtedy, keď vyriešime všetky volania funkcie \lstinline[language=Javascript]{f}.
Používateľ bude vďaka tomto prístupu mať lepší prehľad o tom, ktoré volanie funkcie ešte prebieha
a ktoré je už ukončené návratom hodnoty.

Pri vykresľovaní si pamätáme tri zoznamy: zásobník krokov, zoznam vykreslených a zásobník
nevyriešených vrcholov. Vrchol je v zásobníku nevyriešených vrcholov práve vtedy,
keď je vykreslený ale jeho hodnota ešte nie je odhalená. Na začiatku simulácie je
koreň stromu vykreslený a označený za nevyriešený.

\begin{figure}[h]
\includegraphics[width=\textwidth,height=\textheight,keepaspectratio]{images/bezMemo.png}
\caption{Výpočet piateho Fibonacciho čísla bez memoizácie}
\label{obr:memo}
\end{figure}

Implementujeme dve hlavné funkcie, \lstinline[language=Javascript]{nextStep} a
\lstinline[language=Javascript]{stepBack} čiže krok vpred a krok vzad. Samotné
vykresľovanie sa vykonáva vo funkcii \lstinline[language=Javascript]{redraw},
ktorá podľa stavu vyššie uvedených zoznamov zobrazí strom na plátno.
\subsubsection{Krok vpred}
Pri zavolaní \lstinline[language=Javascript]{nextStep} urobíme krok iba vtedy,
keď existuje aspoň jeden nevyriešený vrchol. V opačnom prípade totiž výpočet už skončil.
Predpokladajme teda, že zásobník nevyriešených vrcholov nie je prázdny. Najprv si zoberieme
posledný vrchol z tohto zásobníka a overíme, či sa ho podarilo v minulom kroku vyriešiť (odhaliť
poslednú potrebnú hodnotu).

Ak áno, do zásobníka krokov pridáme jeho číslo, odstránime ho z nevyriešených vrcholov a
vykreslíme jeho hodnotu.

Ak nie, vykreslíme ďalší vrchol v zozname všetkých vrcholov. Do tohto zoznamu sme
každý vrchol zapisovali pred zistením jeho hodnoty (čiže vytváraním jeho detí), preto
tento zoznam má vrcholy zoradené v poradí, v ktorom boli zavolané.

Pri vykresľovaní ďalšieho vrcholu pridáme do zásobníka krokov -1 a ak nie je list,
pridáme ho do zásobníka nevyriešených vrcholov.

Po konci týchto úkonov zavoláme funkciu \lstinline[language=Javascript]{redraw}.
\subsubsection{Krok vzad}
Pri kroku vzad ako prvé vyberieme posledný krok zo zásobníka krokov. Ak bol tento
krok \textbf{x} väčší alebo rovný 0, vieme, že posledný krok bolo odhalenie hodnoty vrchola s číslom \textbf{x}.
Preto tento vrchol pridáme do zásobníka nevyriešených a skryjeme jeho výsledok.

Ak však posledný krok v zásobníku bol -1, musíme skryť posledný odhalený vrchol.
Ten teda odstránime zo zoznamu vykreslených vrcholov a ak je nevyriešený, tak aj
zo zásobníka nevyriešených.

Nakoniec tiež zavoláme \lstinline[language=Javascript]{redraw}.
\subsection{Vykresľovanie s memoizáciou}
Aby sa používatelia lepšie orientovali v memoizačnom výpočte, na ľavej strane
vykresľovacieho plátna budeme ukazovať zapamätané hodnoty.

Pri odhalení nového vrchola zistíme, či jeho hodnota bola získaná z pamäti.
Ak áno, spojíme ho na jeden krok prerušovanou
čiarou s vrcholom, v ktorom sme túto hodnotu vypočítali a uložili. Ak hodnota práve odhaleného vrchola
 nebola získaná z pamäti, vykreslíme ho ako pri výpočte bez memoizácie.

Odhaľovanie hodnoty doteraz nevyriešených vrcholov je rovnaké, ako bez memoizácie
Pri odhaľovaní hodnoty doteraz nevyriešeného vrchola jeho hodnotu pridáme do vykreslenej pamäti.
\begin{figure}[h]
\includegraphics[width=\linewidth]{images/memoizacia.png}
\caption{Výpočet piateho Fibonacciho čísla s memoizáciou}
\label{obr:memo}
\end{figure}
